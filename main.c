/* Main.c file generated by New Project wizard
 *
 * Created:   Sun Apr 2 2023
 * Processor: PIC16F84A
 * Compiler:  MPLAB XC8
 
 
 
	edit the adc.c lib to increase to 10-bit
		requires lsb to be stores else where
		could change it to 2 nibbles
		
*/

// Configuration settings for the PIC
#pragma config FOSC = XT
#pragma config WDTE = OFF
#pragma config PWRTE = ON
#pragma config CP = OFF
#define _XTAL_FREQ  4000000


#include <stdlib.h> // for utoa rather than use in lcd.h
#include <xc.h>  // for MPLAB
#include "lcd.h" // not using Lcd_Write_Int as i implment it here, saves space
#include "adc.h" // only: uint readADC()

/*
	Basic:
		Displays welcome message with range	on power up
		Displays current DC voltage
		Hold button pauses displayed value----------------------------------NEED TO TEST ON HARDWARE
		Hold button, second press resumes displaying the current value-----NEED TO TEST ON HARDWARE
	Advanced:
		* Second ADC + Differential Voltage switching into view : hardest
		* Peak Hold button : Display max so far alongside current voltage
		* Sampling Button : Store current Value in memory
		* Buzzer Alarm when below some threshold
		* use TMR0 and display the time below the threshold
*/
void main() {
	// Variables and Default Values
	unsigned int currentVoltage;
	unsigned int currentReading;
	TRISA = 0b00000100;
    TRISB = 0b00000001;
    RW = 0;
	char welcomeMsg[] = "Hi:0-4.8V";
	
	
	// Configures bits and clears screen
    Lcd_Init();
	Lcd_Clear();
	
	// Writes Welcome Message to screen with the range of 0-5v
	Lcd_Set_Cursor(1,1);
	Lcd_Write_String(welcomeMsg);
	__delay_ms(1000);
	
	// Every loop: Clears Screen, checks hold button status, updates value to display, converts to milliVolts, converts to char array, prints, tailing zero and unit
    while(1)
    {
		if (RB0 == 1) {
			__delay_ms(200);
			while(RB0 == 0) {__delay_ms(10);} // maybe use delay to de-bounce
		}

        Lcd_Clear();
        Lcd_Set_Cursor(1,1);
		
		
		// the method of masking the last 4 bits(2 that can actually get set) is not perfect but helps to move the value closer to the truth, since the dividing isn't great, but avoids needing the float library
		currentReading = readADC() ;//& 0b0000001111110000; // bit mask to remove 4 lsb, helps offset the difference in dividing by 2
		//if (currentReading > 750) {
			//currentReading -= 175;
		//}
		currentReading = currentReading - ((currentReading >> 3)) + 60;
		
		currentVoltage = (currentReading) >> 1; // divides by 2 : 511/1008 = 0.507; 1008 due to masking the last 4 bits of the 10 bits
	// 400 : 100::::::::::::700 : 150 :::::::::::::::: 1000 : 200 ::::::: +150 N = (-25)*N - 50
		// Using code from lcd.h to reduce instruction memory used
		char lsbVolt[3];
		utoa((char*)lsbVolt, currentVoltage, 10);
		
		Lcd_Write_String(lsbVolt);
		Lcd_Write_Char('0'); // only displays 3 significant digits
		Lcd_Write_Char('m'); // simplifies things and since the range is < 10v , it's not really necessary to use Volts
		Lcd_Write_Char('V');
		
	   
        __delay_ms(100); // for hold button
    }
 }